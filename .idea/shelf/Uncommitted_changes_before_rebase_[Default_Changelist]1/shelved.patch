Index: 2018-2019/learning/telegram_collection_bot/my_links.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>bot_id = '1054467570:AAHTOT3ZxTo01yqh6JTZp4vc4Zxta5xmvzo'\nSCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly']\nfolder = \"'1InPQkzJHuCYkv_Rv9WZHaHEDHVKlsmz_'\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- 2018-2019/learning/telegram_collection_bot/my_links.py	(revision 3b54d16ddbb3d8b04d8df6bf27b3efcf8114aff3)
+++ 2018-2019/learning/telegram_collection_bot/my_links.py	(date 1590144816546)
@@ -1,3 +1,6 @@
 bot_id = '1054467570:AAHTOT3ZxTo01yqh6JTZp4vc4Zxta5xmvzo'
 SCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly']
-folder = "'1InPQkzJHuCYkv_Rv9WZHaHEDHVKlsmz_'"
\ No newline at end of file
+folder = "'1InPQkzJHuCYkv_Rv9WZHaHEDHVKlsmz_'"
+
+counter_all = 0
+counter_match = 0
\ No newline at end of file
Index: 2018-2019/learning/telegram_collection_bot/collect_bot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import telebot\nimport pickle\nimport os.path\nimport my_links\nfrom googleapiclient.discovery import build\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\n\n\n\n#telebot.apihelper.proxy = {'socks5h': 'socks5://telegram.vpn.net:55555'}\n\nbot = telebot.TeleBot(my_links.bot_id)\n\n# If modifying these scopes, delete the file token.pickle.\nSCOPES = my_links.SCOPES\nfolder = my_links.folder\n\n\ndef preparation():\n    creds = None\n    # The file token.pickle stores the user's access and refresh tokens, and is\n    # created automatically when the authorization flow completes for the first\n    # time.\n    if os.path.exists('token.pickle'):\n        with open('token.pickle', 'rb') as token:\n            creds = pickle.load(token)\n    # If there are no (valid) credentials available, let the user log in.\n    if not creds or not creds.valid:\n        if creds and creds.expired and creds.refresh_token:\n            creds.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(\n                'credentials.json', SCOPES)\n            creds = flow.run_local_server(port=0)\n        # Save the credentials for the next run\n        with open('token.pickle', 'wb') as token:\n            pickle.dump(creds, token)\n\n    service = build('drive', 'v3', credentials=creds)\n\n    results = service.files().list(pageSize=1000,\n                                   fields=\"nextPageToken, files(id, name, webViewLink)\",\n                                   q=f\"{folder} in parents\").execute()\n    items = results.get('files', [])\n    return items\n\n\n@bot.message_handler(content_types=['text'])\ndef sending_results(message):\n    counter_all = None\n    counter_match = None\n    items = preparation()\n    if items:\n        counter_all = 0\n        counter_match = 0\n        for item in items:\n            counter_all += 1\n            if message.text.lower() in item['name'].lower():\n                counter_match += 1\n                bot.send_message(message.chat.id, item['name'])\n                bot.send_message(message.chat.id, item['webViewLink'])\n    if counter_match == 0:\n        bot.send_message(message.chat.id, f'Увы, совпадений не найдено')\n    else:\n        bot.send_message(message.chat.id, f'Найдлено {counter_match} совпадений')\n    bot.send_message(message.chat.id, f'Всего найдено {counter_all} экземпляров в коллекции')\n    counter_all = None\n    counter_match = None\n\n\nbot.polling()\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- 2018-2019/learning/telegram_collection_bot/collect_bot.py	(revision 3b54d16ddbb3d8b04d8df6bf27b3efcf8114aff3)
+++ 2018-2019/learning/telegram_collection_bot/collect_bot.py	(date 1590144816554)
@@ -48,25 +48,21 @@
 
 @bot.message_handler(content_types=['text'])
 def sending_results(message):
-    counter_all = None
-    counter_match = None
     items = preparation()
     if items:
-        counter_all = 0
-        counter_match = 0
         for item in items:
-            counter_all += 1
+            my_links.counter_all += 1
             if message.text.lower() in item['name'].lower():
-                counter_match += 1
+                my_links.counter_match += 1
                 bot.send_message(message.chat.id, item['name'])
                 bot.send_message(message.chat.id, item['webViewLink'])
-    if counter_match == 0:
+    if my_links.counter_match == 0:
         bot.send_message(message.chat.id, f'Увы, совпадений не найдено')
     else:
-        bot.send_message(message.chat.id, f'Найдлено {counter_match} совпадений')
-    bot.send_message(message.chat.id, f'Всего найдено {counter_all} экземпляров в коллекции')
-    counter_all = None
-    counter_match = None
+        bot.send_message(message.chat.id, f'Найдлено {my_links.counter_match} совпадений')
+    bot.send_message(message.chat.id, f'Всего найдено {my_links.counter_all} экземпляров в коллекции')
+    my_links.counter_all = 0
+    my_links.counter_match = 0
 
 
 bot.polling()
